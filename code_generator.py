"""
Code Generator Module

Translates Gemini's physics analysis JSON into executable Isaac Sim Python scripts
using USD and PhysX APIs.
"""

import json
import logging
from pathlib import Path
from typing import Dict, Any, List
from config import USD_SCENES_DIR, DEFAULT_SCENE_PARAMS

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class IsaacCodeGenerator:
    """
    Generates Isaac Sim Python scripts from physics analysis data.
    """
    
    def __init__(self):
        """Initialize the code generator."""
        self.script_template = self._load_template()
        logger.info("‚úì IsaacCodeGenerator initialized")
    
    def generate_scene(
        self,
        analysis_data: Dict[str, Any],
        output_path: str | Path,
        headless: bool = True
    ) -> Path:
        """
        Generate a complete Isaac Sim script from analysis data.
        
        Args:
            analysis_data: Physics analysis dictionary from Gemini
            output_path: Where to save the generated script
            headless: Whether to run in headless mode
            
        Returns:
            Path to the generated script
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"üîß Generating Isaac Sim scene script...")
        
        # Extract components
        scene_comp = analysis_data.get("scene_composition", {})
        physics = analysis_data.get("physics_estimation", {})
        lighting = analysis_data.get("lighting_conditions", {})
        camera = analysis_data.get("camera_estimation", DEFAULT_SCENE_PARAMS["camera"])
        
        # Build script sections
        imports = self._generate_imports()
        init_code = self._generate_initialization(headless)
        physics_scene = self._generate_physics_scene(physics)
        environment = self._generate_environment(scene_comp.get("environment", {}))
        objects = self._generate_objects(
            scene_comp.get("objects", []),
            physics.get("objects", [])
        )
        lighting_code = self._generate_lighting(lighting)
        camera_code = self._generate_camera(camera)
        simulation = self._generate_simulation_loop()
        cleanup = self._generate_cleanup()
        
        # Combine all sections
        full_script = f"""{'\"\"\"'}
Generated Isaac Sim Scene Script
Auto-generated by 4D-SynthForge Code Generator
{'\"\"\"'}

{imports}

{init_code}

{physics_scene}

{environment}

{objects}

{lighting_code}

{camera_code}

{simulation}

{cleanup}
"""
        
        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(full_script)
        
        logger.info(f"‚úÖ Script generated: {output_path}")
        logger.info(f"   Objects: {len(scene_comp.get('objects', []))}")
        logger.info(f"   Physics enabled: {len(physics.get('objects', []))}")
        
        return output_path
    
    def _load_template(self) -> str:
        """Load script template."""
        # For now, we build dynamically
        return ""
    
    def _generate_imports(self) -> str:
        """Generate import statements."""
        return """# Isaac Sim and USD imports
from omni.isaac.kit import SimulationApp

# Launch Isaac Sim
simulation_app = SimulationApp({"headless": HEADLESS_MODE})

# Import after SimulationApp initialization
from pxr import Usd, UsdGeom, UsdPhysics, Gf, UsdLux, PhysxSchema
import omni.physx
import omni.replicator.core as rep
import carb
import numpy as np"""
    
    def _generate_initialization(self, headless: bool) -> str:
        """Generate initialization code."""
        # Convert Windows paths to use forward slashes for USD compatibility
        usd_output = str(USD_SCENES_DIR / "generated_scene.usd").replace("\\", "/")
        
        return f"""
# Configuration
HEADLESS_MODE = {headless}
USD_OUTPUT = r"{usd_output}"

# Create a new USD stage
stage = Usd.Stage.CreateNew(USD_OUTPUT)

# Set up metadata
stage.SetMetadata("metersPerUnit", 1.0)
stage.SetMetadata("upAxis", "Y")

# Define World root
world_prim = UsdGeom.Xform.Define(stage, "/World")
stage.SetDefaultPrim(world_prim.GetPrim())

print("‚úì USD stage initialized")"""
    
    def _generate_physics_scene(self, physics: Dict[str, Any]) -> str:
        """Generate PhysX scene setup."""
        gravity = physics.get("gravity", {"x": 0.0, "y": -9.81, "z": 0.0})
        
        return f"""
# Setup PhysX scene
physics_scene = UsdPhysics.Scene.Define(stage, "/World/physicsScene")
physics_scene.CreateGravityDirectionAttr().Set(Gf.Vec3f(0.0, -1.0, 0.0))
physics_scene.CreateGravityMagnitudeAttr().Set({abs(gravity.get('y', 9.81))})

# PhysX scene settings
physx_scene = PhysxSchema.PhysxSceneAPI.Apply(stage.GetPrimAtPath("/World/physicsScene"))
physx_scene.CreateEnableCCDAttr(True)
physx_scene.CreateEnableStabilizationAttr(True)
physx_scene.CreateEnableGPUDynamicsAttr(False)
physx_scene.CreateBroadphaseTypeAttr("MBP")
physx_scene.CreateSolverTypeAttr("TGS")

print("‚úì Physics scene configured")"""
    
    def _generate_environment(self, env_data: Dict[str, Any]) -> str:
        """Generate ground plane and environment."""
        dimensions = env_data.get("dimensions", {"length": 10.0, "width": 10.0})
        material = env_data.get("material", "wood")
        
        length = dimensions.get("length", 10.0)
        width = dimensions.get("width", 10.0)
        
        return f"""
# Create ground plane
ground_path = "/World/Ground"
ground = UsdGeom.Mesh.Define(stage, ground_path)

# Ground geometry (flat plane)
half_l, half_w = {length/2}, {width/2}
points = [
    Gf.Vec3f(-half_l, 0, -half_w),
    Gf.Vec3f(half_l, 0, -half_w),
    Gf.Vec3f(half_l, 0, half_w),
    Gf.Vec3f(-half_l, 0, half_w)
]
ground.CreatePointsAttr(points)
ground.CreateFaceVertexCountsAttr([4])
ground.CreateFaceVertexIndicesAttr([0, 1, 2, 3])
ground.CreateNormalsAttr([Gf.Vec3f(0, 1, 0)] * 4)

# Add collision
UsdPhysics.CollisionAPI.Apply(ground.GetPrim())

# Ground material properties
ground_material = UsdPhysics.MaterialAPI.Apply(ground.GetPrim())
ground_material.CreateStaticFrictionAttr(0.5)
ground_material.CreateDynamicFrictionAttr(0.4)
ground_material.CreateRestitutionAttr(0.3)

print("‚úì Ground plane created")"""
    
    def _generate_objects(
        self,
        scene_objects: List[Dict[str, Any]],
        physics_objects: List[Dict[str, Any]]
    ) -> str:
        """Generate object creation code."""
        code_sections = []
        
        # Create a map of physics properties by object ID
        physics_map = {obj.get("id"): obj for obj in physics_objects}
        
        for i, obj in enumerate(scene_objects):
            obj_id = obj.get("id", f"object_{i}")
            obj_type = obj.get("type", "sphere")
            position = obj.get("position", {"x": 0, "y": 1, "z": 0})
            scale = obj.get("scale", {"x": 1, "y": 1, "z": 1})
            
            physics_props = physics_map.get(obj_id, {})
            
            code = self._generate_single_object(
                obj_id, obj_type, position, scale, physics_props
            )
            code_sections.append(code)
        
        return "\n\n".join(code_sections)
    
    def _generate_single_object(
        self,
        obj_id: str,
        obj_type: str,
        position: Dict[str, float],
        scale: Dict[str, float],
        physics: Dict[str, Any]
    ) -> str:
        """Generate code for a single object."""
        path = f"/World/{obj_id}"
        pos_x, pos_y, pos_z = position.get('x', 0), position.get('y', 1), position.get('z', 0)
        
        # Geometry creation based on type
        if obj_type == "sphere":
            radius = scale.get('x', 0.5)
            geom_code = f"""
# Create {obj_id} (Sphere)
{obj_id}_path = "{path}"
{obj_id} = UsdGeom.Sphere.Define(stage, {obj_id}_path)
{obj_id}.CreateRadiusAttr({radius})
{obj_id}.AddTranslateOp().Set(Gf.Vec3d({pos_x}, {pos_y}, {pos_z}))"""
        
        elif obj_type == "cube":
            size = scale.get('x', 1.0)
            geom_code = f"""
# Create {obj_id} (Cube)
{obj_id}_path = "{path}"
{obj_id} = UsdGeom.Cube.Define(stage, {obj_id}_path)
{obj_id}.CreateSizeAttr({size})
{obj_id}.AddTranslateOp().Set(Gf.Vec3d({pos_x}, {pos_y}, {pos_z}))"""
        
        elif obj_type == "cylinder":
            radius = scale.get('x', 0.5)
            height = scale.get('y', 1.0)
            geom_code = f"""
# Create {obj_id} (Cylinder)
{obj_id}_path = "{path}"
{obj_id} = UsdGeom.Cylinder.Define(stage, {obj_id}_path)
{obj_id}.CreateRadiusAttr({radius})
{obj_id}.CreateHeightAttr({height})
{obj_id}.AddTranslateOp().Set(Gf.Vec3d({pos_x}, {pos_y}, {pos_z}))"""
        
        else:
            # Default to sphere
            geom_code = f"""
# Create {obj_id} (Default Sphere)
{obj_id}_path = "{path}"
{obj_id} = UsdGeom.Sphere.Define(stage, {obj_id}_path)
{obj_id}.CreateRadiusAttr(0.5)
{obj_id}.AddTranslateOp().Set(Gf.Vec3d({pos_x}, {pos_y}, {pos_z}))"""
        
        # Add physics if available
        if physics:
            mass = physics.get('mass', 1.0)
            velocity = physics.get('initial_velocity', {'x': 0, 'y': 0, 'z': 0})
            restitution = physics.get('restitution', 0.5)
            static_friction = physics.get('static_friction', 0.3)
            dynamic_friction = physics.get('dynamic_friction', 0.25)
            
            physics_code = f"""
# Add physics to {obj_id}
rigid_body = UsdPhysics.RigidBodyAPI.Apply(stage.GetPrimAtPath({obj_id}_path))
rigid_body.CreateVelocityAttr(Gf.Vec3f({velocity.get('x', 0)}, {velocity.get('y', 0)}, {velocity.get('z', 0)}))

mass_api = UsdPhysics.MassAPI.Apply(stage.GetPrimAtPath({obj_id}_path))
mass_api.CreateMassAttr({mass})

UsdPhysics.CollisionAPI.Apply(stage.GetPrimAtPath({obj_id}_path))

material_api = UsdPhysics.MaterialAPI.Apply(stage.GetPrimAtPath({obj_id}_path))
material_api.CreateStaticFrictionAttr({static_friction})
material_api.CreateDynamicFrictionAttr({dynamic_friction})
material_api.CreateRestitutionAttr({restitution})

print(f"‚úì Created {obj_id} with physics")"""
        else:
            physics_code = f"""
print(f"‚úì Created {obj_id} (static)")"""
        
        return geom_code + "\n" + physics_code
    
    def _generate_lighting(self, lighting: Dict[str, Any]) -> str:
        """Generate lighting setup."""
        dome = lighting.get("dome_light", {})
        key_light = lighting.get("key_light", {})
        
        dome_intensity = dome.get("intensity", 1000.0)
        key_intensity = key_light.get("intensity", 5000.0)
        key_pos = key_light.get("position", {"x": 5, "y": 5, "z": 5})
        
        return f"""
# Create dome light
dome_light = UsdLux.DomeLight.Define(stage, "/World/DomeLight")
dome_light.CreateIntensityAttr({dome_intensity})
dome_light.CreateTextureFileAttr("./materials/kloofendal_48d_partly_cloudy_puresky_4k.hdr")

# Create key light
key_light = UsdLux.SphereLight.Define(stage, "/World/KeyLight")
key_light.CreateIntensityAttr({key_intensity})
key_light.CreateRadiusAttr(0.5)
key_light.AddTranslateOp().Set(Gf.Vec3d({key_pos.get('x', 5)}, {key_pos.get('y', 5)}, {key_pos.get('z', 5)}))

print("‚úì Lighting configured")"""
    
    def _generate_camera(self, camera: Dict[str, Any]) -> str:
        """Generate camera setup."""
        position = camera.get("position", {"x": 0, "y": 1.5, "z": 3})
        look_at = camera.get("look_at", {"x": 0, "y": 0.5, "z": 0})
        focal_length = camera.get("focal_length", 50.0)
        
        return f"""
# Create camera
camera = UsdGeom.Camera.Define(stage, "/World/Camera")
camera.CreateFocalLengthAttr({focal_length})
camera.CreateFocusDistanceAttr(100)
camera.AddTranslateOp().Set(Gf.Vec3d({position.get('x', 0)}, {position.get('y', 1.5)}, {position.get('z', 3)}))

# Camera look-at (simplified)
# For proper look-at, calculate rotation based on target
print("‚úì Camera configured")"""
    
    def _generate_simulation_loop(self) -> str:
        """Generate simulation and rendering loop."""
        return """
# Save USD file
stage.Save()
print(f"‚úì USD scene saved: {USD_OUTPUT}")

# Run simulation
if not HEADLESS_MODE:
    print("\\nüé¨ Running interactive simulation...")
    print("   Close the Isaac Sim window to exit")
    
    # Keep simulation running
    import omni.timeline
    timeline = omni.timeline.get_timeline_interface()
    timeline.play()
    
    # Wait for user to close
    while simulation_app.is_running():
        simulation_app.update()
else:
    print("\\nüé¨ Running headless simulation...")
    
    # Run for fixed duration
    import omni.timeline
    timeline = omni.timeline.get_timeline_interface()
    timeline.play()
    
    # Simulate for 5 seconds at 60 FPS
    for frame in range(300):
        simulation_app.update()
        if frame % 60 == 0:
            print(f"   Frame {frame}/300")
    
    timeline.stop()
    print("‚úì Simulation complete")"""
    
    def _generate_cleanup(self) -> str:
        """Generate cleanup code."""
        return """
# Cleanup
simulation_app.close()
print("\\n‚úÖ Scene generation complete!")"""


def generate_scene_from_json(json_path: str | Path, output_script: str | Path) -> Path:
    """
    Command-line helper to generate scene from JSON file.
    
    Args:
        json_path: Path to analysis JSON
        output_script: Path for output Python script
        
    Returns:
        Path to generated script
    """
    with open(json_path, 'r') as f:
        analysis_data = json.load(f)
    
    generator = IsaacCodeGenerator()
    return generator.generate_scene(analysis_data, output_script)


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python code_generator.py <analysis_json>")
        print("\\nExample:")
        print("  python code_generator.py output/ball_cup_analysis.json")
        sys.exit(1)
    
    json_file = sys.argv[1]
    output_file = USD_SCENES_DIR / "generated_scene.py"
    
    try:
        script_path = generate_scene_from_json(json_file, output_file)
        print(f"\\n‚úÖ Script generated: {script_path}")
        print(f"\\nüöÄ Run with Isaac Sim:")
        print(f"   ~/.local/share/ov/pkg/isaac_sim-*/python.sh {script_path}")
    except Exception as e:
        print(f"\\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
