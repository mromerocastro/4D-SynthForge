"""
IsaacLab Scene Generator

Generates IsaacLab-compatible scene scripts from physics analysis data.
"""

import json
import logging
from pathlib import Path
from typing import Dict, Any, List
from config import USD_SCENES_DIR, DEFAULT_SCENE_PARAMS

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class IsaacLabSceneGenerator:
    """
    Generates IsaacLab Python scripts from physics analysis data.
    """
    
    def __init__(self):
        """Initialize the code generator."""
        logger.info("‚úì IsaacLabSceneGenerator initialized")
    
    def generate_scene(
        self,
        analysis_data: Dict[str, Any],
        output_path: str | Path,
    ) -> Path:
        """
        Generate an IsaacLab-compatible scene script.
        
        Args:
            analysis_data: Physics analysis dictionary from Gemini
            output_path: Where to save the generated script
            
        Returns:
            Path to the generated script
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"üîß Generating IsaacLab scene script...")
        
        # Extract components
        scene_comp = analysis_data.get("scene_composition", {})
        physics = analysis_data.get("physics_estimation", {})
        
        # Build script
        imports = self._generate_imports()
        scene_class = self._generate_scene_class(scene_comp, physics)
        main_function = self._generate_main()
        
        # Convert Windows paths
        usd_output = str(USD_SCENES_DIR / "generated_scene.usd").replace("\\", "/")
        
        full_script = f'''"""
Generated IsaacLab Scene Script
Auto-generated by 4D-SynthForge Code Generator
Compatible with IsaacLab framework
"""

{imports}

# Configuration
USD_OUTPUT_PATH = r"{usd_output}"

{scene_class}

{main_function}
'''
        
        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(full_script)
        
        logger.info(f"‚úÖ IsaacLab script generated: {output_path}")
        logger.info(f"   Objects: {len(scene_comp.get('objects', []))}")
        
        return output_path
    
    def _generate_imports(self) -> str:
        """Generate IsaacLab-compatible imports."""
        return """import argparse
from omni.isaac.lab.app import AppLauncher

# Parse arguments for IsaacLab
parser = argparse.ArgumentParser(description="4D-SynthForge Generated Scene")
parser.add_argument("--num_envs", type=int, default=1, help="Number of environments")
parser.add_argument("--headless", action="store_true", help="Run headless")
AppLauncher.add_app_launcher_args(parser)
args_cli = parser.parse_args()

# Launch the app
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

# Import Isaac Lab modules
from omni.isaac.lab.sim import SimulationCfg, SimulationContext
from omni.isaac.lab.utils.assets import ISAAC_NUCLEUS_DIR
import omni.isaac.core.utils.prims as prim_utils
from pxr import Usd, UsdGeom, UsdPhysics, Gf, PhysxSchema
import numpy as np"""
    
    def _generate_scene_class(self, scene_comp: Dict, physics: Dict) -> str:
        """Generate scene setup function."""
        objects = scene_comp.get("objects", [])
        physics_objects = physics.get("objects", [])
        physics_map = {obj.get("id"): obj for obj in physics_objects}
        
        # Build object creation code
        object_code = []
        for i, obj in enumerate(objects):
            obj_id = obj.get("id", f"object_{i}")
            obj_type = obj.get("type", "sphere")
            position = obj.get("position", {"x": 0, "y": 1, "z": 0})
            scale = obj.get("scale", {"x": 0.5, "y": 0.5, "z": 0.5})
            physics_props = physics_map.get(obj_id, {})
            
            pos_str = f"({position.get('x', 0)}, {position.get('y', 1)}, {position.get('z', 0)})"
            
            if obj_type == "sphere":
                radius = scale.get('x', 0.5)
                object_code.append(f"""
    # Create {obj_id} (Sphere)
    {obj_id}_prim = prim_utils.create_prim(
        "/World/{obj_id}",
        "Sphere",
        translation={pos_str},
        attributes={{"radius": {radius}}}
    )
    
    # Add rigid body physics
    rigid_body_api = UsdPhysics.RigidBodyAPI.Apply({obj_id}_prim)
    collision_api = UsdPhysics.CollisionAPI.Apply({obj_id}_prim)
    physx_collision_api = PhysxSchema.PhysxCollisionAPI.Apply({obj_id}_prim)
    
    mass_api = UsdPhysics.MassAPI.Apply({obj_id}_prim)
    mass_api.CreateMassAttr({physics_props.get('mass', 1.0)})
    
    material_api = UsdPhysics.MaterialAPI.Apply({obj_id}_prim)
    material_api.CreateStaticFrictionAttr({physics_props.get('static_friction', 0.3)})
    material_api.CreateDynamicFrictionAttr({physics_props.get('dynamic_friction', 0.25)})
    material_api.CreateRestitutionAttr({physics_props.get('restitution', 0.5)})
    
    print(f"‚úì Created {obj_id}")""")
            
            elif obj_type == "cylinder":
                radius = scale.get('x', 0.5)
                height = scale.get('y', 1.0)
                object_code.append(f"""
    # Create {obj_id} (Cylinder)
    {obj_id}_prim = prim_utils.create_prim(
        "/World/{obj_id}",
        "Cylinder",
        translation={pos_str},
        attributes={{"radius": {radius}, "height": {height}}}
    )
    
    # Add rigid body physics
    rigid_body_api = UsdPhysics.RigidBodyAPI.Apply({obj_id}_prim)
    collision_api = UsdPhysics.CollisionAPI.Apply({obj_id}_prim)
    
    mass_api = UsdPhysics.MassAPI.Apply({obj_id}_prim)
    mass_api.CreateMassAttr({physics_props.get('mass', 1.0)})
    
    material_api = UsdPhysics.MaterialAPI.Apply({obj_id}_prim)
    material_api.CreateStaticFrictionAttr({physics_props.get('static_friction', 0.3)})
    material_api.CreateRestitutionAttr({physics_props.get('restitution', 0.5)})
    
    print(f"‚úì Created {obj_id}")""")
        
        objects_code = "\n".join(object_code)
        
        return f'''
def setup_scene(sim: SimulationContext):
    """Setup the physics scene with objects."""
    
    # Get stage
    stage = sim.stage
    
    # Create ground plane
    ground_prim = prim_utils.create_prim(
        "/World/Ground",
        "Plane",
        translation=(0, 0, 0),
        attributes={{"axis": "Y", "extent": 5.0}}
    )
    
    # Add collision to ground
    collision_api = UsdPhysics.CollisionAPI.Apply(ground_prim)
    material_api = UsdPhysics.MaterialAPI.Apply(ground_prim)
    material_api.CreateStaticFrictionAttr(0.5)
    material_api.CreateDynamicFrictionAttr(0.4)
    material_api.CreateRestitutionAttr(0.3)
    
    print("‚úì Ground plane created")
    
    # Create physics scene
    scene_prim = stage.GetPrimAtPath("/physicsScene")
    if not scene_prim.IsValid():
        scene = UsdPhysics.Scene.Define(stage, "/physicsScene")
        scene.CreateGravityDirectionAttr().Set(Gf.Vec3f(0.0, -1.0, 0.0))
        scene.CreateGravityMagnitudeAttr().Set(9.81)
        print("‚úì Physics scene configured")
{objects_code}
    
    # Save USD
    stage.Export(USD_OUTPUT_PATH)
    print(f"‚úì USD scene saved: {{USD_OUTPUT_PATH}}")
'''
    
    def _generate_main(self) -> str:
        """Generate main execution function."""
        return '''
def main():
    """Main function to run the simulation."""
    
    # Setup simulation
    sim_cfg = SimulationCfg(dt=1/60, substeps=1)
    sim = SimulationContext(sim_cfg)
    
    # Setup scene
    print("\\n" + "="*60)
    print("4D-SYNTHFORGE - Isaac Lab Scene")
    print("="*60 + "\\n")
    
    setup_scene(sim)
    
    # Reset simulation
    sim.reset()
    
    # Run simulation
    print("\\nüé¨ Running simulation...")
    print("   Press Ctrl+C to stop")
    
    try:
        for i in range(300):  # 5 seconds at 60fps
            sim.step()
            if i % 60 == 0:
                print(f"   Frame {i}/300")
        
        print("‚úì Simulation complete")
        
    except KeyboardInterrupt:
        print("\\n‚ö†Ô∏è  Simulation interrupted by user")
    
    finally:
        # Cleanup
        simulation_app.close()
        print("\\n‚úÖ Scene generation complete!")


if __name__ == "__main__":
    main()
'''


def generate_isaaclab_scene(json_path: str | Path, output_script: str | Path) -> Path:
    """
    Generate IsaacLab scene from JSON file.
    
    Args:
        json_path: Path to analysis JSON
        output_script: Path for output Python script
        
    Returns:
        Path to generated script
    """
    with open(json_path, 'r') as f:
        analysis_data = json.load(f)
    
    generator = IsaacLabSceneGenerator()
    return generator.generate_scene(analysis_data, output_script)


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python isaaclab_generator.py <analysis_json>")
        print("\\nExample:")
        print("  python isaaclab_generator.py output/ball_cup_analysis.json")
        sys.exit(1)
    
    json_file = sys.argv[1]
    output_file = USD_SCENES_DIR / "isaaclab_scene.py"
    
    try:
        script_path = generate_isaaclab_scene(json_file, output_file)
        print(f"\\n‚úÖ IsaacLab script generated: {script_path}")
        print(f"\\nüöÄ Run with IsaacLab:")
        print(f"   isaaclab.bat -p {script_path}")
    except Exception as e:
        print(f"\\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
